/**
 * @module react-oauth2-hook
 * @requires prop-types
 * @requires react
 * @requires react-dom
 * @summary Retrieve OAuth2 implicit grant tokens purely on the client without destroying application state.
 * @version 1.0.10
 * @author zemnmez
 * @copyright zemnmez 2019
 * @license MIT
 * ## Installation
 * 
 * ```bash
 * yarn add react-oauth2-hook
 * ```
 * ## Overview
 * This package provides an entirely client-side flow to get OAuth2 implicit grant tokens.
 * It's implemented as a react hook, [[useOAuth2Token]], with a fairly simple API
 * and a react component, [[OAuthCallback]] which should be mounted at the
 * OAuth callback endpoint.
 * 
 * Take a look at the [Example](#example) for usage information.
 * 
 * ## Security Considerations
 * OAuth 2 is a very sensitive protocol. I've done my best to provide good security
 * guarantees with this package.
 * 
 * I assume that your application follows reasonable best practices like using `X-Frame-Options`
 * to prevent clickjacking based attacks.
 * 
 * ### State
 * The State token prevents an attacker from forcing a user to sign in as the attacker's
 * account using a kind of CSRF. Here, I am cautious against multiple types of attacks.
 * 
 * My state token is not signed, it's a completely static concatenation of some entropy
 * generated by webcrypto and a key, composed of `JSON.stringify({ authUrl, clientID, scopes })`.
 * When the callback is recieved by [[OAuthCallback]], it is compared strictly
 * to the stored value, and otherwise rejected.
 * 
 * This prevents both attacks where an attacker would try to submit a token to the user's
 * browser without their consent, and attacks where a malicious OAuth server would
 * (re)use the n-once to authenticate a callback from a different server.
 * 
 * ### Timing attacks
 * 
 * The state token is *not* compared using a fixed-time string comparison.
 * Where typically, this would lead to an attacker being able to use a lot of time
 * and statistics to side-channel out the state token, this
 * should be irrelevant in this configuration, this should be extremely difficult
 * to pull off accurately as any timing information would be inaccessible or heavily
 * diluted.
 * 
 * ## Refresh tokens
 * This library in-and-of-itself does not acquire long lived refresh tokens. Though
 * some OAuth servers allow implicit clients to acquire refresh tokens without an
 * OAuth secret, this isn't part of the OAuth standard. Instead, consider
 * simply triggering the authorize flow when the token expires -- if the user
 * is still authorized, the window should almost immediately close. Otherwise,
 * you can use any special APIs that would let you do this, or skip this library
 * entirely and try PKCE.
 * ## Example
 * @example
 * 
 * ```javascript
 * import React from 'react'
 * import { BrowserRouter as Router, Switch } from 'react-router-dom'
 * import { useOAuth2Token, OAuthCallback } from 'react-oauth2-hook'
 * 
 * // in this example, we get a Spotify OAuth
 * // token and use it to show a user's saved
 * // tracks.
 * 
 * export default () => <Router>
 *   <Switch>
 *     <Route path="/callback" component={OAuthCallback}/>
 *     <Route component={SavedTracks}/>
 *   </Switch>
 * </Router>
 * 
 * const SavedTracks = () => {
 *   const [token, getToken] = useOAuth2Token({
 *     authorizeUrl: "https://accounts.spotify.com/authorize",
 *     scope: ["user-library-read"],
 *     clientID: "bd9844d654f242f782509461bdba068c",
 *     redirectUri: document.location.href+"/callback"
 *   })
 * 
 *   const [tracks, setTracks] = React.useState();
 *   const [error, setError] = React.useState();
 * 
 *   // query spotify when we get a token
 *   React.useEffect(() => {
 *     fetch(
 *       'https://api.spotify.com/v1/me/tracks?limit=50'
 *     ).then(response => response.json()).then(
 *       data => setTracks(data)
 *     ).catch(error => setError(error))
 *   }, [token])
 * 
 *   return <div>
 *     {error && `Error occurred: ${error}`}
 *     {(!token || !savedTracks) && <div
 *       onClick={getToken}>
 *         login with Spotify
 *     </div>}
 *     {savedTracks && `
 *       Your Saved Tracks: ${JSON.stringify(savedTracks)}
 *     `}
 *   </div>
 * }
 * ```
 * 
 */

/**
 *  
 */


