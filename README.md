## Overview
This package provides an entirely client-side flow to get OAuth2 implicit grant tokens.
It's implemented as a react hook, [[useOAuth2Token]], with a fairly simple API
and a react component, [[OAuthCallback]] which should be mounted at the
OAuth callback endpoint.

Take a look at the [Example](#example) for usage information.

## Security Considerations
OAuth 2 is a very sensitive protocol. I've done my best to provide good security
guarantees with this package.

I assume that your application follows reasonable best practices like using `X-Frame-Options`
to prevent clickjacking based attacks.

### State
The State token prevents an attacker from forcing a user to sign in as the attacker's
account using a kind of CSRF. Here, I am cautious against multiple types of attacks.

My state token is not signed, it's a completely static concatenation of some entropy
generated by webcrypto and a key, composed of `JSON.stringify({ authUrl, clientID, scopes })`.
When the callback is recieved by [[OAuthCallback]], it is compared strictly
to the stored value, and otherwise rejected.

This prevents both attacks where an attacker would try to submit a token to the user's
browser without their consent, and attacks where a malicious OAuth server would
(re)use the n-once to authenticate a callback from a different server.

### Timing attacks

The state token is *not* compared using a fixed-time string comparison.
Where typically, this would lead to an attacker being able to use a lot of time
and statistics to side-channel out the state token, this
should be irrelevant in this configuration, this should be extremely difficult
to pull off accurately as any timing information would be inaccessible or heavily
diluted.

## Refresh tokens
This library in-and-of-itself does not acquire long lived refresh tokens. Though
some OAuth servers allow implicit clients to acquire refresh tokens without an
OAuth secret, this isn't part of the OAuth standard. Instead, consider
simply triggering the authorize flow when the token expires -- if the user
is still authorized, the window should almost immediately close. Otherwise,
you can use any special APIs that would let you do this, or skip this library
entirely and try PKCE.
